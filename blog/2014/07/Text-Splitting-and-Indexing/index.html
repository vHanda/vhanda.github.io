<!doctype html><html dir=ltr lang=en data-theme class=html><head><title>Vishesh Handa
|
Text Splitting and Indexing</title><meta charset=utf-8><meta name=generator content="Hugo 0.96.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="Vishesh Handa"><meta name=description content="
      


    "><link rel=stylesheet href=/scss/main.min.5259d55db7b9c675f751f0865411bd84a410f3ffcb5105b8fc00b22fcb739309.css integrity="sha256-UlnVXbe5xnX3UfCGVBG9hKQQ8//LUQW4/ACyL8tzkwk=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.69685904d5c2a0c6258d03c207b778c10466edf6cea928cc0164c376b0ad0930.css integrity="sha256-aWhZBNXCoMYljQPCB7d4wQRm7fbOqSjMAWTDdrCtCTA=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.6d585e78d28cce1200d39fb133c92ed83df01738da721d0f48fb6eac62d24e04.css integrity="sha256-bVheeNKMzhIA05+xM8ku2D3wFzjach0PSPturGLSTgQ=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.6b00d96498d59caa0dbcf9b49d30d821915291f2ceb0e19248523c8607ff43fa.css integrity="sha256-awDZZJjVnKoNvPm0nTDYIZFSkfLOsOGSSFI8hgf/Q/o=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=canonical href=http://vhanda.in/blog/2014/07/Text-Splitting-and-Indexing/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.560a26330d27ff44a44e83b53cd07a95d4230a65930d31c5c76a8d481e5b35bf.js integrity="sha256-VgomMw0n/0SkToO1PNB6ldQjCmWTDTHFx2qNSB5bNb8=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Text Splitting and Indexing"><meta name=twitter:description content="Over the last week, we have been working on improving the file searching experience in Plasma. We were mostly doing a decent job, but we were lacking in terms of proper Unicode support and making it simpler to search in non English languages. This blog post is a simplified explanation about now what goes on internally.
For the purpose of this discussion, I&rsquo;m going to treat all files as blobs of text."><meta property="og:title" content="Text Splitting and Indexing"><meta property="og:description" content="Over the last week, we have been working on improving the file searching experience in Plasma. We were mostly doing a decent job, but we were lacking in terms of proper Unicode support and making it simpler to search in non English languages. This blog post is a simplified explanation about now what goes on internally.
For the purpose of this discussion, I&rsquo;m going to treat all files as blobs of text."><meta property="og:type" content="article"><meta property="og:url" content="http://vhanda.in/blog/2014/07/Text-Splitting-and-Indexing/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2014-07-31T13:28:51+00:00"><meta property="article:modified_time" content="2014-07-31T13:28:51+00:00"><meta property="og:site_name" content="Vishesh Handa"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"blog","name":"Text Splitting and Indexing","headline":"Text Splitting and Indexing","alternativeHeadline":"","description":"
      
        Over the last week, we have been working on improving the file searching experience in Plasma. We were mostly doing a decent job, but we were lacking in terms of proper Unicode support and making it simpler to search in non English languages. This blog post is a simplified explanation about now what goes on internally.\nFor the purpose of this discussion, I\u0026rsquo;m going to treat all files as blobs of text.


      


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/vhanda.in\/blog\/2014\/07\/Text-Splitting-and-Indexing\/"},"author":{"@type":"Person","name":"Vishesh Handa"},"creator":{"@type":"Person","name":"Vishesh Handa"},"accountablePerson":{"@type":"Person","name":"Vishesh Handa"},"copyrightHolder":{"@type":"Person","name":"Vishesh Handa"},"copyrightYear":"2014","dateCreated":"2014-07-31T13:28:51.00Z","datePublished":"2014-07-31T13:28:51.00Z","dateModified":"2014-07-31T13:28:51.00Z","publisher":{"@type":"Organization","name":"Vishesh Handa","url":"http://vhanda.in","logo":{"@type":"ImageObject","url":"http:\/\/vhanda.infavicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"http:\/\/vhanda.in\/blog\/2014\/07\/Text-Splitting-and-Indexing\/","wordCount":"908","genre":[],"keywords":["planetkde"]}</script></head><body class="body theme--light"><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/images/profile.jpg alt="profile picture"><h1 class=sidebar__introduction-title><a href=/>Vishesh Handa</a></h1><div class=sidebar__introduction-description><p></p></div></div><ul class=sidebar__list><li class=sidebar__list-item><a href=https://www.linkedin.com/in/visheshhanda/ rel=me aria-label=Linkedin title=Linkedin><i class="fab fa-linkedin fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://github.com/vhanda rel=me aria-label=GitHub title=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://twitter.com/visheshhanda rel=me aria-label=Twitter title=Twitter><i class="fab fa-twitter fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=mailto:me@vhanda.in rel=me aria-label=e-mail title=e-mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
Vishesh Handa
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.a3fd0638ada4e3cec287e49a604b4a828cfef33a669afe60b96575761fff5cf3.js integrity="sha256-o/0GOK2k487Ch+SaYEtKgoz+8zpmmv5guWV1dh//XPM=" crossorigin=anonymous></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Text Splitting and Indexing</h1><p>Over the last week, we have been working on improving the file searching experience in Plasma. We were mostly doing a decent job, but we were lacking in terms of proper Unicode support and making it simpler to search in non English languages. This blog post is a simplified explanation about now what goes on internally.</p><p>For the purpose of this discussion, I&rsquo;m going to treat all files as blobs of text.</p><h2 id=how-indexing-works>How indexing works?</h2><p>When we&rsquo;re indexing a file we typically have to take all the text and split it into words. This process is called Text Segmentation or Tokenization.</p><p>The most trivial implementation of this is just splitting on any white space. However, in practice it gets way more complex as punctuations need to be taken into account. Fortunately, there is an <a href=http://www.unicode.org/reports/tr29/>existing standard</a> for this.</p><p>After obtaining the words one needs to simplify the words. Since Plasma is not dependent on one language when we do this, we need to do it in a language independent manner.</p><p>Currently we do the following -</p><ul><li><p>Strip all <a href=http://en.wikipedia.org/wiki/Diacritic>diacritic marks</a>. So words such as &lsquo;mañana&rsquo; become &lsquo;manana&rsquo;.</p></li><li><p><a href=http://unicode.org/reports/tr15/>Simplify</a> all the characters. The moment you move away from the simple english characters, stuff gets complex. The same word can be represented in multiple ways in memory. For example the letter <code>ñ</code> can be written as <code>ñ</code> or as <code>n + ◌̃</code>. We want to consume the minimum number of characters to represent it.</p></li></ul><p>Finally, we&rsquo;re ready to store the words. We generally store them in a big table where every word corresponds to the file it was found in.</p><p><img src=/blog/images/2014/07/31/g4715.png alt></p><p>Here each file is represented by a number in order to save space.</p><p>We additionally also store where in the file every word was found. This comes at an expensive cost as with Xapian storing positional information doubles your database size. This means slower indexing and more IO consumption.</p><h2 id=how-searching-works>How searching works?</h2><p>The initial part of search process is quite similar to the indexing process. When we get a string to search for, we split it up into words, and then simplify each word in the exact fashion we did when indexing those words.</p><p>After this we simply lookup each of the words in the table and return the set of files which matched every word.</p><p>For example if we were searching for the words <code>árk Zombie</code> in the above table. It would look as follows.</p><p><code>ark AND zombie</code> -> <code>(1, 3, 8) AND (6, 8)</code> -> <code>8</code>.</p><h3 id=phrases>Phrases</h3><p>The explanation above works for simple words, but the moment you bring in more complex words, stuff starts to get a little messy.</p><p>Imagine searching for an email address <code>vhanda@kde.org</code>. This would be split into 3 words <code>vhanda</code>, <code>kde</code> and <code>org</code> We could just search for these 3 words, but that&rsquo;s not exactly what the user expected. They expect these words to appear in that exact order. This is where the positional information that we stored during indexing is used. We now search for those 3 words but we make sure they appear consecutively.</p><p>This does give some minor false positives such as a document containing the text &ldquo;vhanda kde org&rdquo;. But in general, it gives us what we want. It also allows users to explicitly search for words appearing consecutively.</p><h3 id=filtering-vs-searching>Filtering vs Searching</h3><p>Searching on the Desktop is quite different than searching on the web. Not only are we expected to be much faster, the wealth of information available is much smaller. This results in users expecting searches to work as a filter.</p><p>When searching on the web, one generally types the full word. On the desktop, however, depending on the feedback one will only type a part fo the word.</p><p>Example: Say searching for a file with the name <code>Dominion - The Flood</code>. One can expect the user to start typing <code>Dom</code> see many other results pop up and then type <code>flood</code> in order to get the desired file. They might never actually type the full word <code>dominion</code>.</p><p>Searching by typing only parts of the word gets more complex from an implementation point of view. We only have a mapping from <code>(word) -> (file)</code>. So in order to search for a part of the word, we need to iterate over the table and look for every word which starts with that prefix. This makes the query quite long.</p><p>Example: Searching for <code>Fi rol</code> might expand to <code>(fi OR fight OR fill finger OR fire) AND (rol OR role OR roller OR rollex)</code></p><p>This whole method of expanding the prefix to every word breaks down when the word is extremely small. Depending on your index expanding one word could result in over 10000 words. Practically, it results in results much much larger than 10000, and that makes the query slower and consumes a crazy amount of memory to represent the query. In these cases we typically try to guess which words occur more frequently than others and only expand the word to the most frequently occurring words.</p><h3 id=so-whats-changed>So, what&rsquo;s changed?</h3><p>With Plasma 5.1, we&rsquo;ve moved away from using Xapian&rsquo;s internal Query Parser and word segmentation engine. We&rsquo;re using our own custom implementation in <a href=http://qt-project.org/doc/qt-5/QTextBoundaryFinder.html>Qt</a>.</p><p>This gives us more control over the entire process, it makes it more testable as we have unit tests for every condition, and lets us modify it in custom ways such as splitting on <code>_</code>, removing diacritic marks and expanding every word when searching for queries.</p></div><div class=post__footer><span><a class=tag href=/tags/planetkde/>planetkde</a></span></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
Vishesh Handa
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.a3fd0638ada4e3cec287e49a604b4a828cfef33a669afe60b96575761fff5cf3.js integrity="sha256-o/0GOK2k487Ch+SaYEtKgoz+8zpmmv5guWV1dh//XPM=" crossorigin=anonymous></script></body></html>