<!doctype html><html dir=ltr lang=en data-theme class=html><head><title>Vishesh Handa
|
Shared Memory Hash Table</title><meta charset=utf-8><meta name=generator content="Hugo 0.96.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="Vishesh Handa"><meta name=description content="
      


    "><link rel=stylesheet href=/scss/main.min.5259d55db7b9c675f751f0865411bd84a410f3ffcb5105b8fc00b22fcb739309.css integrity="sha256-UlnVXbe5xnX3UfCGVBG9hKQQ8//LUQW4/ACyL8tzkwk=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.69685904d5c2a0c6258d03c207b778c10466edf6cea928cc0164c376b0ad0930.css integrity="sha256-aWhZBNXCoMYljQPCB7d4wQRm7fbOqSjMAWTDdrCtCTA=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.6d585e78d28cce1200d39fb133c92ed83df01738da721d0f48fb6eac62d24e04.css integrity="sha256-bVheeNKMzhIA05+xM8ku2D3wFzjach0PSPturGLSTgQ=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.6b00d96498d59caa0dbcf9b49d30d821915291f2ceb0e19248523c8607ff43fa.css integrity="sha256-awDZZJjVnKoNvPm0nTDYIZFSkfLOsOGSSFI8hgf/Q/o=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=canonical href=http://vhanda.in/blog/2012/07/Shared-Memory-Hash-Table/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.560a26330d27ff44a44e83b53cd07a95d4230a65930d31c5c76a8d481e5b35bf.js integrity="sha256-VgomMw0n/0SkToO1PNB6ldQjCmWTDTHFx2qNSB5bNb8=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Shared Memory Hash Table"><meta name=twitter:description content="For the last month I&rsquo;ve been working on a hash table which is stored in shared memory and can thus easily be used across applications. This is ideal for simple caches of data that reside in multiple applications. My specific use case was the Nepomuk Resource class, which is a glorified cache of key value pairs and uses a hash table. A considerable amount of effort has gone into making sure that each application&rsquo;s Resource classes are consistent with the other applications."><meta property="og:title" content="Shared Memory Hash Table"><meta property="og:description" content="For the last month I&rsquo;ve been working on a hash table which is stored in shared memory and can thus easily be used across applications. This is ideal for simple caches of data that reside in multiple applications. My specific use case was the Nepomuk Resource class, which is a glorified cache of key value pairs and uses a hash table. A considerable amount of effort has gone into making sure that each application&rsquo;s Resource classes are consistent with the other applications."><meta property="og:type" content="article"><meta property="og:url" content="http://vhanda.in/blog/2012/07/Shared-Memory-Hash-Table/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2012-07-19T14:16:43+00:00"><meta property="article:modified_time" content="2012-07-19T14:16:43+00:00"><meta property="og:site_name" content="Vishesh Handa"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"blog","name":"Shared Memory Hash Table","headline":"Shared Memory Hash Table","alternativeHeadline":"","description":"
      
        For the last month I\u0026rsquo;ve been working on a hash table which is stored in shared memory and can thus easily be used across applications. This is ideal for simple caches of data that reside in multiple applications. My specific use case was the Nepomuk Resource class, which is a glorified cache of key value pairs and uses a hash table. A considerable amount of effort has gone into making sure that each application\u0026rsquo;s Resource classes are consistent with the other applications.


      


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/vhanda.in\/blog\/2012\/07\/Shared-Memory-Hash-Table\/"},"author":{"@type":"Person","name":"Vishesh Handa"},"creator":{"@type":"Person","name":"Vishesh Handa"},"accountablePerson":{"@type":"Person","name":"Vishesh Handa"},"copyrightHolder":{"@type":"Person","name":"Vishesh Handa"},"copyrightYear":"2012","dateCreated":"2012-07-19T14:16:43.00Z","datePublished":"2012-07-19T14:16:43.00Z","dateModified":"2012-07-19T14:16:43.00Z","publisher":{"@type":"Organization","name":"Vishesh Handa","url":"http://vhanda.in","logo":{"@type":"ImageObject","url":"http:\/\/vhanda.infavicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"http:\/\/vhanda.in\/blog\/2012\/07\/Shared-Memory-Hash-Table\/","wordCount":"1176","genre":[],"keywords":["planetkde","nepomuk"]}</script></head><body class="body theme--light"><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/images/profile.jpg alt="profile picture"><h1 class=sidebar__introduction-title><a href=/>Vishesh Handa</a></h1><div class=sidebar__introduction-description><p></p></div></div><ul class=sidebar__list><li class=sidebar__list-item><a href=https://www.linkedin.com/in/visheshhanda/ rel=me aria-label=Linkedin title=Linkedin><i class="fab fa-linkedin fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://github.com/vhanda rel=me aria-label=GitHub title=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://twitter.com/visheshhanda rel=me aria-label=Twitter title=Twitter><i class="fab fa-twitter fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=mailto:me@vhanda.in rel=me aria-label=e-mail title=e-mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
Vishesh Handa
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.a3fd0638ada4e3cec287e49a604b4a828cfef33a669afe60b96575761fff5cf3.js integrity="sha256-o/0GOK2k487Ch+SaYEtKgoz+8zpmmv5guWV1dh//XPM=" crossorigin=anonymous></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Shared Memory Hash Table</h1><p>For the last month I&rsquo;ve been working on a hash table which is stored in
shared memory and can thus easily be used across applications. This is
ideal for simple caches of data that reside in multiple applications. My
specific use case was the <a href=http://api.kde.org/4.x-api/kdelibs-apidocs/nepomuk-core/html/classNepomuk2_1_1Resource.html>Nepomuk Resource</a> class, which is a
glorified cache of key value pairs and uses a hash table. A considerable
amount of effort has gone into making sure that each application&rsquo;s
Resource classes are consistent with the other applications.</p><p>I always thought something this basic would have been implemented, but I
just couldn&rsquo;t find a shared memory hash table which actually supported
resizing.</p><h1 id=basic-hash-table>Basic Hash Table</h1><p>Hashing is arguably one of the most important concepts of computer
science. If you aren&rsquo;t aware of how it works here are some nice links -</p><ol><li><a href=http://en.wikipedia.org/wiki/Hash_table>Wikipedia Article</a></li><li><a href=https://class.coursera.org/algo/lecture/preview>Video lectures from algo-class.org</a></li><li><a href=http://www.catonmat.net/blog/mit-introduction-to-algorithms-part-five/>Video lectures from MIT</a></li></ol><h1 id=shared-memory-hash-table>Shared Memory Hash Table</h1><p>When implementing a hash table in shared memory, one encounters a couple
of problems which normal hash tables do not have to deal with. Namely
&rsquo;named memory locations&rsquo;. In the Unix world each shared memory location
has to be given a unique identifier so that it can be accessed by other
applications. Because of that we cannot allocate each Node/Bucket
independently.</p><h2 id=most-hash-tables-which-handle-collisions-by-chaining-look-like-this>Most hash tables, which handle collisions <a href=http://www.algolist.net/Data_structures/Hash_table/Chaining>by chaining</a> look like this</h2><p><img src=/blog/images/2012/07/19/normal-hash-table.png alt="Normal Hash Table"></p><p>Allocating a new named shared memory region for each node seems like
quite an overkill.</p><h2 id=structure>Structure</h2><p>Since everything has to fit inside a contiguous memory location, we need
to structure the hash table a little differently.</p><p><img src=/blog/images/2012/07/19/shared-memory-hash-table.png alt="Shared Memory Hash Table"></p><p>We use two shared memory locations - <code>HashName</code> and <code>HashData</code>. This is
done cause a hash table is not fixed in size, and will need to be
reallocated. With the reallocations, a new named shared memory will have
to be created, and all existing clients would need to be informed to use
this newly allocated location which would have a different name.</p><p>Instead we use <code>HashName</code> as the unique identifier the client knows
about, and <code>HashData</code> is internally used and can be changed when the
hash table needs to grow in size.</p><h3 id=hash-name-data>Hash Name data</h3><p><img src=/blog/images/2012/07/19/hash-name.png alt="Hash Name"></p><p>The additional integer is a micro optimization. Whenever a client needs
to use the hash table they need to make sure that they are connected to
the appropriate shared memory, and not the old version. The code does
that by checking if <code>HashData</code> name is the same as the same as the one
provided by <code>HashName</code>.</p><p>This results in a string comparison, which would take a certain number
of cycles depending on the length of the string. We use an additional
integer to indicate the if the string has changed. Integer comparisons
are a lot faster than string comparisons.</p><h3 id=internal-data>Internal Data</h3><p><img src=/blog/images/2012/07/19/hash-data.png alt="Hash Internal Data"></p><p>Most of the initial members are quite obvious, but I&rsquo;m still listing
them.</p><p><strong>Size</strong>: The number of elements in the hash table</p><p><strong>Capacity</strong>: The total number of elements the hash table can hold</p><p><strong>Invalid</strong>: The number of buckets that invalid (have been deleted)</p><p><strong>Empty-Bucket</strong>: The offset of the next empty bucket which may be used
for insertion</p><p>After this comes the array of offsets referred internally as m_buckets.
This array instead of holding the pointers to the Buckets, like in a
traditional hash table, it holds offsets from the beginning of the next
array.</p><p>The next array is an array of Bucket s, which is internally referred to
as m_data. This array holds the key value pairs. A typical Bucket is
defined as -</p><pre><code>struct Bucket {
    KeyType key;
    ValueType value;
    int hash;
    int link;
}
</code></pre><p>The <code>link</code> member is again not a pointer, but it contains the integer
offset to the next Bucket from the start of <code>m_data</code>.</p><h2 id=insertions>Insertions</h2><p>Insert operations are quite simple. The <code>key</code> is hashed into an integer,
which after a modulo operation is used as the index.</p><p>The corresponding <code>index</code> is checked in <code>m_buckets</code>. If <code>m_buckets</code> does
not already have some value over there, there is no collision and we
just allocate a new Bucket and plug in its offset.</p><p>Allocations of new buckets are done by consuming the location given by
<code>emptyBucket</code>, and then incrementing its value.</p><p>If <code>m_buckets</code> does not have an empty value, we go to the corresponding
Bucket, and follow its link until the link is empty. At that point we
allocate a new node and make the link point to this new Bucket. This
approach is almost identical to that of conventional chaining, except
that we are using offsets instead of pointers.</p><h2 id=deletions>Deletions</h2><p>Delete operations are fairly similar to insertions. The index is
procured by hashing they key, and performing a modulo operation with the
capacity. After which m_buckets is used to get the offset of the actual
Bucket. Instead of deleting the bucket, which would not be possible
cause it is stored in an array, we simply mark it as invalid.</p><p>The number of invalid buckets is then updated, and m_buckets[index] is
marked as empty. Later during the resize operation, the wasted memory
will be cleaned up.</p><p><em>Note: Deletions are actually a little more complex because of
collisions, but you just need to traverse the entire link chain, and
mark the corresponding Bucket as invalid</em></p><h2 id=resizing>Resizing</h2><p>The resize operation occurs when the loadRatio of the hash table goes
above a certain threshold. For now, I&rsquo;ve set it to 0.8.</p><p><strong>loadRatio</strong> = (invalid-buckets + size) / capacity</p><p>When the loadRatio goes above 0.8, a new shared memory location is
allocated. The metadata (size, capacity, invalid and empty-Bucket) are
initially copied to the new shared memory. After which the offset for
each bucket is recalculated ( <code>hash % newCapacity</code> ), and it is inserted
into the new shared memory.</p><p>The invalid buckets are ignored and they are not copied.</p><p>Once the copying is completed, the hash data key in <code>HashName</code> is
updated, the id is incremented. This is done so that all other
applications using the shared memory can update their internal pointers.</p><h2 id=iterating>Iterating</h2><p>Iterating over the hash table is probably the only operation that is a
lot simpler than traditional hash tables. We already have all the data
listed as an array - <code>m_data</code>. All we need to do is iterate over it
while discarding invalid buckets which were created by delete
operations.</p><p>Well, in theory.</p><p>In practice, safely iterating over a shared hash involves copying the
element being accessed. Mainly because another application could have
shrunk the entire memory and your index could no longer be valid.</p><p>Another possible way is to copy its contents to a <code>QHash</code>. I&rsquo;ve
implemented a simple function for that.</p><h2 id=problems>Problems</h2><h3 id=dynamically-allocated-types>Dynamically allocated Types</h3><p>You cannot use any types which dynamically allocate memory as the <code>key</code>
or <code>value</code>. This rules out <code>QString</code>, <code>QUrl</code>, <code>QVariant</code> (kinda) and
most of the commonly used Qt Data Structures. If you need to use a
string as the key, you&rsquo;ll need to explicitly set an upper limit by using
something like <code>QVarLengthArray</code>.</p><p>This is a huge problem, and makes using the shared hash very difficult
in practice.</p><h2 id=source-code>Source Code</h2><p>All of the code is currently lying in my scratch repository -
<a href="http://gitweb.kde.org/index.php?p=scratch%2Fvhanda%2Fsharedhash.git&a=summary">kde:scratch/vhanda/sharedhash</a></p></div><div class=post__footer><span><a class=tag href=/tags/planetkde/>planetkde</a><a class=tag href=/tags/nepomuk/>nepomuk</a></span></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
Vishesh Handa
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.a3fd0638ada4e3cec287e49a604b4a828cfef33a669afe60b96575761fff5cf3.js integrity="sha256-o/0GOK2k487Ch+SaYEtKgoz+8zpmmv5guWV1dh//XPM=" crossorigin=anonymous></script></body></html>